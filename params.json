{"name":"Transponder","tagline":"Transponder is a opinionated javascript library for assisting in working with front end heavy rails app.","body":"![Transponder Banner](http://transponder.s3-ap-northeast-1.amazonaws.com/transponder-banner.png)\r\n\r\n8kb uncompressed / 2kb minified & compressed (gzip) (client side library)\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n    gem 'transponder'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install transponder\r\n\r\n\r\n## Generate a basic Module \r\n\r\nA transponder module provides some basic structure for your javascript code\r\n```\r\nrails g transponder:install application\r\n```\r\nThis will generate a transponder 'module' in your ```app/assets/javascripts``` folder by the name of 'application', you can change the ```application``` to something else, but we recommend sticking with defaults until you understand more about transponder.\r\n\r\n## Generate a Presenter\r\n\r\nPresenters is perhaps one of the most important thing about Transponder, it allows you to use your server side templates in your client side code, cleanly and allows better reuseability of code.\r\n\r\n```\r\nrails g transponder:presenter contacts\r\n```\r\n\r\nRunning this command will generate a presenter in your Transponder module ```application/presenters``` with the name ```contacts_presenter.coffee```\r\n\r\n\r\n## How is this better than Rails UJS?\r\n\r\nTypically with Rails UJS you would create a view with something like this \r\n\r\nLets say you have a basic contacts_controller.rb\r\n\r\n```ruby\r\nclass ContactsController < ApplicationController\r\n  respond_to :json, :html, :js\r\n\r\n  def index\r\n    @contacts = Contact.all\r\n    respond_with @contacts\r\n  end\r\nend\r\n```\r\n\r\nIn your ```index.js.erb``` you would then have something like this \r\n\r\n```js\r\n$('#contacts').html(\"<%= j render @contacts %>\");\r\n```\r\n\r\nThis Javascript code is evaled in the browser and content of the node with the id ```#contacts``` gets replaced with server side template that came from ```<%= j render @contacts %>``` This is fine however it has a few problems. First of all if you use coffeescript it has to be compiled in real time as its responding which adds to your response time. Secondly if you want to do more complex things in your response things can get very messy. Code reuse isn't that great either.\r\n\r\nWith Transponder you have a consistent way of working with your server side template. Lets take a look at the difference\r\n\r\nIn your ```index.js.erb``` transponder version would look something like this.\r\n\r\n```js\r\n[\"#contacts\", \"<%= xms_event %>\", \"<%= j render @contacts %>\"]\r\n```\r\n\r\nYour server side response code using transponder will mostly likely look something like this. There is consistency to it. The first element is the DOM node you want to manipulate, the second element is what will allow the client side Transponder code to know which Presenter is responsible for this response and lastly we have the server side generated content.\r\n\r\n### So what happens once this response gets to the client\r\n\r\nWell in our presenter we would do something like this \r\n\r\n```coffee\r\nclass Application.Presenters.ContactsPresenter extends Transponder.Presenter\r\n  presenterName: 'contacts'\r\n  module: 'application'\r\n\r\n  index: ->\r\n    $(@element).html(@response)\r\n    # ... do more stuff ...\r\n```\r\n\r\nThe first 3 lines of code are generated by the presenter generator you were just using before the only line of code you should pay attention to here is the last 2. Basically the ```@element``` is the dom element you specified in ```index.js.erb``` and the ```@response``` is the content that was rendered by the server.\r\n\r\nIn the presenter you can do pretty much anything you want to your response before it gets output to the DOM. This gives a nice structure and consistency to the whole pattern. It allows you to mix server side templates with full client side programmability.\r\n\r\nTesting is also much easier as now you've shifted the responsibility of the client side behavior to the client. We have more documentation coming on how to test your presenters.\r\n\r\n## Example App\r\n\r\nHere is a link to a more typical example with a controller / presenter that is more fleshed out. [Presenters: Typical Example](https://github.com/xpdr/transponder/wiki/Presenters:-Typical-Example). The code in the link is the controller / presenter code for this app here \r\n+ [kontax on heroku](http://kontax.herokuapp.com)\r\n+ [kontax on github](http://github.com/xpdr/kontax)\r\n\r\nKontax is an example app for showcasing what Transponder is capable of doing. The larger and more complex an app becomes the more transponder shines. Especially if you want to build apps that need real time stuff.\r\n\r\n## TODO - Whats Coming\r\n\r\n  + Add Documentation\r\n  + Video Screencasts\r\n  + Add more features to Kontax\r\n  + More documentation on Services\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n\r\n## Credits\r\nGem developed by [Zack Siri](http://github.com/zacksiri) of [Artellectual](http://www.artellectual.com)","google":"UA-46213366-1","note":"Don't delete this file! It's used internally to help with page regeneration."}